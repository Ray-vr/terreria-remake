<!DOCTYPE html>
<html>
<head>
  <title>Terraria-Like Game</title>
</head>
<body>
<canvas id="game" width="800" height="600"></canvas>
<script>
// Style
document.body.style.margin = "0";
document.body.style.overflow = "hidden";
document.body.style.backgroundColor = "#222";
const canvas = document.getElementById("game");
canvas.style.display = "block";
canvas.style.margin = "auto";
canvas.style.backgroundColor = "#87CEEB";

// Constants
const ctx = canvas.getContext("2d");
const tileSize = 40;
const worldWidth = 300;
const worldHeight = 40;
let cameraX = 0;

// Biome types
const BIOMES = ["forest", "desert", "jungle", "underworld"];
const COLORS = {
  forest: "#228B22",
  desert: "#DEB887",
  jungle: "#006400",
  underworld: "#4B0082",
  dirt: "#654321"
};

// Generate world with biomes
let world = Array.from({ length: worldHeight }, () => Array(worldWidth).fill(0));
let biomeMap = [];
for (let x = 0; x < worldWidth; x++) {
  let biome = BIOMES[Math.floor(x / (worldWidth / BIOMES.length))];
  biomeMap[x] = biome;
  for (let y = worldHeight / 2; y < worldHeight; y++) {
    world[Math.floor(y)][x] = biome;
  }
}

// Add floating islands
for (let i = 0; i < 5; i++) {
  let ix = Math.floor(Math.random() * worldWidth);
  let iy = Math.floor(Math.random() * worldHeight / 2);
  for (let y = -1; y <= 1; y++) {
    for (let x = -2; x <= 2; x++) {
      if (world[iy + y] && world[iy + y][ix + x] !== undefined) {
        world[iy + y][ix + x] = "dirt";
      }
    }
  }
}

// Player
let player = {
  x: 10,
  y: 10,
  vx: 0,
  vy: 0,
  width: 1,
  height: 1,
  grounded: false
};

// Draw world
function drawWorld() {
  for (let y = 0; y < worldHeight; y++) {
    for (let x = 0; x < worldWidth; x++) {
      let tile = world[y][x];
      if (tile) {
        ctx.fillStyle = COLORS[tile] || "#000";
        ctx.fillRect((x - cameraX) * tileSize, y * tileSize, tileSize, tileSize);
      }
    }
  }
}

// Draw player
function drawPlayer() {
  ctx.fillStyle = "#00f";
  ctx.fillRect((player.x - cameraX) * tileSize, player.y * tileSize, tileSize, tileSize);
}

// Physics
function updatePhysics() {
  player.vy += 0.5;
  player.x += player.vx;
  player.y += player.vy;

  player.grounded = false;
  for (let y = Math.floor(player.y); y < Math.ceil(player.y + player.height); y++) {
    for (let x = Math.floor(player.x); x < Math.ceil(player.x + player.width); x++) {
      if (world[y] && world[y][x]) {
        if (player.vy > 0) {
          player.y = y - player.height;
          player.vy = 0;
          player.grounded = true;
        } else if (player.vy < 0) {
          player.y = y + 1;
          player.vy = 0;
        }
      }
    }
  }

  player.x = Math.max(0, Math.min(worldWidth - player.width, player.x));
  player.y = Math.min(worldHeight - player.height, player.y);
  cameraX = Math.floor(player.x - canvas.width / tileSize / 2);
  cameraX = Math.max(0, Math.min(worldWidth - canvas.width / tileSize, cameraX));
}

// Render
function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawWorld();
  drawPlayer();
}

// Game loop
function gameLoop() {
  updatePhysics();
  render();
  requestAnimationFrame(gameLoop);
}

// Controls
document.addEventListener("keydown", (e) => {
  if (e.key === "ArrowLeft") player.vx = -0.2;
  if (e.key === "ArrowRight") player.vx = 0.2;
  if (e.key === " " && player.grounded) player.vy = -10;
});
document.addEventListener("keyup", (e) => {
  if (e.key === "ArrowLeft" || e.key === "ArrowRight") player.vx = 0;
});

// Click to toggle blocks
canvas.addEventListener("click", (e) => {
  const x = Math.floor(e.offsetX / tileSize + cameraX);
  const y = Math.floor(e.offsetY / tileSize);
  if (world[y] && world[y][x] !== undefined) {
    world[y][x] = world[y][x] ? 0 : "dirt";
  }
});

gameLoop();
</script>
</body>
</html>
